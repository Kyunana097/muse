C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Headers;.\sources) DEBUG OB
                    -JECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Headers/oled.h"
   3          #include "Headers/oledfont.h"
   4          #include "Headers/RTX51TNY.H"
   5          #include "Headers/music.h"
   6          
   7          sbit KEY1 = P3 ^ 1;
   8          sbit KEY2 = P3 ^ 0;
   9          sbit KEY3 = P3 ^ 2;
  10          sbit KEY4 = P3 ^ 3;
  11          
  12          // 游戏状态变量
  13          bit game_state = 0;          // 0: 主菜单，1: 游戏进行中
  14          bit setting_state = 0;       // 0: 主菜单，1: 设置界面
  15          bit info_state = 0;         // 0: 主菜单，1: 制作信息界面
  16          bit isPlaying = 0;           // 0: 没有正在游玩的游戏 1; 正在游戏中
  17          
  18          volatile unsigned short track1_score = 0;
  19          volatile unsigned short track2_score = 0;
  20          volatile unsigned short temp_score = 0;
  21          volatile unsigned char track_num = 1;           // 1: 第一关，2: 第二关
  22          volatile unsigned char board_num = 1;           // 1: start 2: setting 3: info
  23          volatile unsigned char x_position = 119;        //音符起始位置 119+8=127
  24          volatile unsigned char speed = 4;               //音符移动速度 1-8
  25          
  26          //即将转移至包装的数据
  27          bit KEY4_pressed = 0;        // 判定状态
  28          // 将 speed 转换为字符串
  29          char speed_str[2];  // 1位数字 + '\0'
  30          volatile unsigned char temp ;
  31          volatile unsigned char hit_time = 0;
  32          volatile unsigned char current_track = 1;//音符列位置 1-2
  33          
  34          // 初始化任务
  35          void task_init(void) _task_ 0
  36          {
  37   1          P2 = 0xFF;
  38   1          OLED_Init();
  39   1          OLED_Clear();
  40   1          os_wait(K_IVL, 50, 0);
  41   1      
  42   1          //显示菜单教程
  43   1          OLED_ShowString(3, 0, "QG Dash v2.6", 8);
  44   1          OLED_ShowString(3, 2, "Key1:up", 8);
  45   1          OLED_ShowString(3, 3, "Key2:down", 8);
  46   1          OLED_ShowString(3, 4, "Key3:comfirm", 8);
  47   1          OLED_ShowString(3, 6, "Loading...", 8);
  48   1          
  49   1          os_wait(K_IVL, 1000, 0);
  50   1          OLED_ShowString(3, 6, "Welcome!  ", 8);
  51   1          os_wait(K_IVL, 100, 0);
  52   1      
  53   1          os_create_task(1);  // 按键任务（优先级1）
  54   1          os_create_task(2);  // 菜单任务（优先级2）
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 2   

  55   1          //os_create_task(3);  // 游戏任务（优先级3）
  56   1          //os_create_task(4);  // 积分任务（优先级4）
  57   1          //os_create_task(5);  // 设置任务（优先级5）
  58   1      
  59   1          os_delete_task(0);  // 删除自身
  60   1      }
  61          
  62          // 按键与判定任务
  63          void task_key(void) _task_ 1
  64          {
  65   1          while(1)
  66   1          {
  67   2              /*主菜单中
  68   2              * key1 = up
  69   2              * key2 = down
  70   2              * key3 = comfirm
  71   2              */
  72   2              if (game_state == 0 && setting_state == 0 && info_state == 0)
  73   2              {
  74   3                  if (KEY1 == 0)
  75   3                  {
  76   4                      os_wait(K_IVL, 3, 0); // 消抖
  77   4                      if (KEY1 == 0)         //确认按钮按下
  78   4                      {
  79   5                          os_wait(K_IVL, 10, 0); // 消抖
  80   5                          board_num--;       //向上
  81   5                          if(board_num < 1)
  82   5                              board_num = 3; //越界循环
  83   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
  84   5                      }
  85   4                  }
  86   3                  
  87   3                  if (KEY2 == 0)
  88   3                  {
  89   4                      os_wait(K_IVL, 3, 0); // 消抖
  90   4                      if (KEY2 == 0)         //确认按钮按下
  91   4                      {
  92   5                          os_wait(K_IVL, 10, 0); // 消抖
  93   5                          board_num++;        //向下
  94   5                          if(board_num > 3)
  95   5                              board_num = 1;//越界循环
  96   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);// 等待释放
  97   5                      }
  98   4                     
  99   4                  }
 100   3                  
 101   3                  if (KEY3 == 0)
 102   3                  {
 103   4                      os_wait(K_IVL, 3, 0); // 消抖
 104   4                      if (KEY3 == 0)         //等待按键释放
 105   4                      {
 106   5                          os_wait(K_IVL, 10, 0); // 消抖  
 107   5                          switch (board_num)
 108   5                          {
 109   6                          //game选项下按下确认按键
 110   6                          case 1:
 111   6                              //进入游戏二级菜单
 112   6                              game_state = 1;
 113   6                              break;
 114   6                      
 115   6                          //setting选项下按下确认按键
 116   6                          case 2:
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 3   

 117   6                              setting_state = 1;
 118   6                              os_delete_task(2);  //挂起菜单
 119   6                              os_create_task(5);  //启动设置任务（优先级5）
 120   6                              break;
 121   6      
 122   6                          //info选项下按下确认按钮
 123   6                          case 3:
 124   6                              //进入info二级菜单
 125   6                              info_state = 1;
 126   6                              break;
 127   6                          }
 128   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 129   5                      }
 130   4                      
 131   4                  }
 132   3                  os_wait(K_IVL, 10, 0);      //释放内存
 133   3              }
 134   2              /**游戏二级菜单中
 135   2               * key 1 = up
 136   2               * key 2 = down
 137   2               * key 3 = comfirm
 138   2               * key 4 = back
 139   2               */
 140   2              if (game_state == 1 && isPlaying == 0)
 141   2              {
 142   3                  if (KEY1 == 0)
 143   3                  {
 144   4                      os_wait(K_IVL, 3, 0); // 消抖
 145   4                      if (KEY1 == 0)         //确认按钮按下
 146   4                      {
 147   5                          os_wait(K_IVL, 10, 0); // 消抖
 148   5                          track_num--;       //向上
 149   5                          if (track_num < 1)
 150   5                              track_num = 2; //越界循环
 151   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
 152   5                      }
 153   4                  }
 154   3      
 155   3                  if (KEY2 == 0)
 156   3                  {
 157   4                      os_wait(K_IVL, 3, 0); // 消抖
 158   4                      if (KEY2 == 0)         //确认按钮按下
 159   4                      {
 160   5                          os_wait(K_IVL, 10, 0); // 消抖
 161   5                          track_num++;        //向下
 162   5                          if (track_num > 2)
 163   5                              track_num = 1;//越界循环
 164   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);// 等待释放
 165   5                      }
 166   4      
 167   4                  }
 168   3      
 169   3                  if (KEY3 == 0)
 170   3                  {
 171   4                      os_wait(K_IVL, 3, 0); // 消抖
 172   4                      if (KEY3 == 0)         //等待按键释放
 173   4                      {
 174   5                          os_wait(K_IVL, 10, 0); // 消抖  
 175   5                          //激活当前停留的轨道
 176   5                          isPlaying = 1;
 177   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 178   5                      }
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 4   

 179   4                      os_delete_task(2);  //挂起菜单
 180   4                      os_create_task(3);  //启动游戏任务（优先级3）
 181   4                  }
 182   3      
 183   3                  //返回上级菜单
 184   3                  if (KEY4 == 0)
 185   3                  {
 186   4                      os_wait(K_IVL, 3, 0); // 消抖
 187   4                      if (KEY4 == 0)
 188   4                      {
 189   5                          os_wait(K_IVL, 10, 0); // 消抖  
 190   5                          while (KEY4 == 0) os_wait(K_IVL, 1, 0);
 191   5                      }
 192   4                      game_state = 0;
 193   4                      os_wait(K_IVL, 3, 0);
 194   4                  }
 195   3                  os_wait(K_IVL, 10, 0);      //释放内存
 196   3              } 
 197   2      
 198   2              /**制作信息二级菜单中
 199   2               * key 3 = quit
 200   2               */
 201   2              if (info_state == 1)
 202   2              {
 203   3                  //退出二级菜单
 204   3                  if (KEY3 == 0)
 205   3                  {
 206   4                      os_wait(K_IVL, 3, 0); // 消抖
 207   4                      if (KEY3 == 0);        
 208   4                      {
 209   5                          os_wait(K_IVL, 10, 0); // 消抖  
 210   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 211   5                      }
 212   4                      os_wait(K_IVL, 100, 0);
 213   4                      info_state = 0;
 214   4                  }
 215   3              }
 216   2      
 217   2              /*游戏中
 218   2              * key1 = sky
 219   2              * key2 = ground
 220   2              * key3 = quit
 221   2              * key4 = pause（暂时不写）
 222   2              */
 223   2              if (game_state == 1 && isPlaying == 1)
 224   2              {
 225   3      
 226   3                  //退出游戏
 227   3                  if (KEY3 == 0)
 228   3                  {
 229   4                      os_wait(K_IVL, 3, 0); // 消抖
 230   4                      if (KEY3 == 0)
 231   4                      {
 232   5                          os_wait(K_IVL, 10, 0); // 消抖  
 233   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 234   5                      }
 235   4                      OLED_Clear();
 236   4                      isPlaying = 0;
 237   4                      os_wait(K_IVL, 100, 0);
 238   4                  }
 239   3      
 240   3              }
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 5   

 241   2      
 242   2              /*设置中
 243   2              * key1 = speed plus
 244   2              * key2 = speed less
 245   2              * key3 = comfirm & quit
 246   2              * key4 = tap
 247   2              */
 248   2              if (setting_state == 1)
 249   2              {
 250   3                  //speed减少
 251   3                  if (KEY1 == 0)
 252   3                  {
 253   4                      os_wait(K_IVL, 3, 0); // 消抖
 254   4                      if (KEY1 == 0)
 255   4                      {
 256   5                          os_wait(K_IVL, 10, 0); // 消抖
 257   5                          speed--;       //speed减少
 258   5                          if (speed < 2)
 259   5                              speed = 1; //越界循环
 260   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
 261   5      
 262   5                      }
 263   4                      
 264   4                  }
 265   3      
 266   3                  //speed增加
 267   3                  if (KEY2 == 0)
 268   3                  {
 269   4                      os_wait(K_IVL, 3, 0); // 消抖
 270   4                      if (KEY2 == 0)         
 271   4                      {
 272   5                          os_wait(K_IVL, 10, 0); // 消抖
 273   5                          speed++;        //speed增加
 274   5                          if (speed > 7)
 275   5                              speed = 8;//越界循环
 276   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);
 277   5      
 278   5                      }
 279   4                  }
 280   3      
 281   3                  //退出设置
 282   3                  if (KEY3 == 0)
 283   3                  {
 284   4                      os_wait(K_IVL, 3, 0); // 消抖
 285   4                      if (KEY3 == 0)         
 286   4                      {
 287   5                          os_wait(K_IVL, 10, 0); // 消抖  
 288   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 289   5                      }
 290   4                      setting_state = 0;
 291   4                      os_wait(K_IVL, 3, 0);
 292   4                  }
 293   3      
 294   3                  //判定
 295   3                  if (KEY4 == 0)
 296   3                  {
 297   4                      os_wait(K_IVL, 3, 0); // 消抖
 298   4                      if (KEY4 == 0)
 299   4                      {
 300   5                          os_wait(K_IVL, 10, 0); // 消抖  
 301   5                          while (KEY4 == 0) os_wait(K_IVL, 1, 0);
 302   5                      }
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 6   

 303   4                      KEY4_pressed = 1; 
 304   4                      hit_time = (x_position - 16) / speed;
 305   4                      os_wait(K_IVL, 3, 0);
 306   4                      if (x_position < 40 && KEY4_pressed == 1)
 307   4                      {
 308   5                          if (hit_time < 1)
 309   5                          {
 310   6                              OLED_ShowString(3, 6, "Perfect", 8);
 311   6                          }
 312   5                          else if (hit_time < 2)
 313   5                          {
 314   6                              OLED_ShowString(3, 6, "Good   ", 8);
 315   6                          }
 316   5                          else if (hit_time < 3)
 317   5                          {
 318   6                              OLED_ShowString(3, 6, "Bad    ", 8);
 319   6                          }
 320   5                          x_position = 121 - speed * 2;
 321   5                          KEY4_pressed = 0;
 322   5                      }
 323   4                      os_wait(K_IVL, 3, 0);
 324   4                  }
 325   3      
 326   3                  os_wait(K_IVL, 10, 0);      //释放内存
 327   3                  
 328   3              }
 329   2             
 330   2          }
 331   1      }
 332          
 333          // 菜单任务
 334          void task_board(void) _task_ 2
 335          {
 336   1          OLED_Clear();
 337   1          while (1)
 338   1          {  
 339   2              os_wait(K_IVL, 10, 0);
 340   2              P2 = 0xAA;
 341   2              //主菜单
 342   2              while (game_state == 0 && setting_state == 0 && info_state == 0)
 343   2              {
 344   3                  OLED_ShowString(25, 0, "Start", 16);
 345   3                  OLED_ShowString(25, 3, "Setting", 16);
 346   3                  OLED_ShowString(25, 6, "Info", 16);
 347   3                  switch (board_num)
 348   3                  {
 349   4                  case 1: 
 350   4                      OLED_ShowString(3, 0, ">>", 16);
 351   4                      OLED_ShowString(3, 3, "  ", 16);
 352   4                      OLED_ShowString(3, 6, "  ", 16);
 353   4                      break;
 354   4      
 355   4                  case 2: 
 356   4                      OLED_ShowString(3, 0, "  ", 16);
 357   4                      OLED_ShowString(3, 3, ">>", 16);
 358   4                      OLED_ShowString(3, 6, "  ", 16);
 359   4                      break;
 360   4      
 361   4                  case 3: 
 362   4                      OLED_ShowString(3, 0, "  ", 16);
 363   4                      OLED_ShowString(3, 3, "  ", 16);
 364   4                      OLED_ShowString(3, 6, ">>", 16);
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 7   

 365   4                      break;
 366   4                  }
 367   3                  os_wait(K_IVL, 10, 0);  
 368   3              }
 369   2      
 370   2              //游戏二级菜单
 371   2              if (game_state == 1 && isPlaying == 0)
 372   2              {
 373   3                  OLED_Clear();
 374   3                  OLED_ShowString(3, 1, "Key1:up", 8);
 375   3                  OLED_ShowString(3, 2, "Key2:down", 8);
 376   3                  OLED_ShowString(3, 3, "Key3:comfirm", 8);
 377   3                  OLED_ShowString(3, 4, "Key4:back", 8);
 378   3                  OLED_ShowString(3, 6, "Loading...", 8);
 379   3                  os_wait(K_IVL, 1000, 0);
 380   3                  OLED_ShowString(3, 6, "          ", 8);
 381   3                  OLED_Clear();
 382   3                  while (game_state == 1 && isPlaying == 0 )
 383   3                  {
 384   4                      OLED_ShowString(25, 0, "Track 1", 16);
 385   4                      OLED_ShowString(25, 3, "Track 2", 16);
 386   4                      OLED_ShowString(3, 6, "top:", 8);
 387   4                      switch (track_num)
 388   4                      {
 389   5                      case 1:
 390   5                          OLED_ShowString(3, 0, ">>", 16);
 391   5                          OLED_ShowString(3, 3, "  ", 16);
 392   5                          OLED_ShowValue(40, 6, track1_score, 8);
 393   5                          break;
 394   5      
 395   5                      case 2:
 396   5                          OLED_ShowString(3, 0, "  ", 16);
 397   5                          OLED_ShowString(3, 3, ">>", 16);
 398   5                          OLED_ShowValue(40, 6, track2_score, 8);
 399   5                          break;
 400   5                      }
 401   4                  }
 402   3                  OLED_Clear();
 403   3                  os_wait(K_IVL, 100, 0);
 404   3              }
 405   2              
 406   2              //制作信息二级菜单
 407   2              if (info_state == 1)
 408   2              {
 409   3                  OLED_Clear();
 410   3                  while (info_state == 1)
 411   3                  {
 412   4                      OLED_ShowString(3, 0, "Auth:Kyunana", 16);
 413   4                      OLED_ShowString(3, 3, "25/4/2025", 8);
 414   4                      OLED_ShowString(3, 4, "in AT89C52RC", 8);
 415   4                      OLED_ShowString(3, 5, "V2.6", 8);
 416   4                      OLED_ShowString(3, 6, "press 3 to quit", 16);
 417   4                      os_wait(K_IVL, 1000, 0);
 418   4                  }
 419   3                  OLED_Clear();
 420   3                  os_wait(K_IVL, 10, 0);
 421   3              }
 422   2          }
 423   1      }
 424          
 425          // 游戏任务
 426          void task_game(void) _task_ 3
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 8   

 427          {
 428   1          while (1)  
 429   1          {
 430   2              if (game_state == 1)
 431   2              {
 432   3                  isPlaying = 1;
 433   3                  OLED_Clear();
 434   3                  P2 = 0x01;
 435   3                  OLED_ShowString(3, 3, "Loading...", 16);
 436   3                  os_create_task(4);  //激活积分
 437   3      
 438   3                  //Track1
 439   3                  while (game_state == 1 && track_num == 1 && isPlaying == 1)
 440   3                  {
 441   4                      OLED_Clear();
 442   4                      OLED_ShowString(3, 3, "Track1 now", 16);
 443   4                      OLED_ShowString(3, 6, "Loading...", 8);
 444   4                      Music_Init(Track1); 
 445   4                      os_wait(K_IVL, 1000, 0);
 446   4                      OLED_Clear();
 447   4                      while (isPlaying == 1)
 448   4                      {
 449   5                          OLED_ShowString(3, 0, "game end", 16);
 450   5                          OLED_ShowString(3, 3, "your score", 16);
 451   5                          OLED_ShowValue(3, 6, track1_score, 16);
 452   5                          os_wait(K_IVL, 1000, 0); 
 453   5                          isPlaying = 0;
 454   5                      }
 455   4                  }
 456   3      
 457   3                  //Track2
 458   3                  while (game_state == 1 && track_num == 2 && isPlaying == 1)
 459   3                  {
 460   4                      OLED_Clear();
 461   4                      OLED_ShowString(3, 3, "Track2 now", 16);
 462   4                      OLED_ShowString(3, 6, "Loading...", 8);
 463   4                      Music_Init(Track2);
 464   4      
 465   4                      os_wait(K_IVL, 1000, 0);
 466   4                      OLED_Clear(); 
 467   4                      while (isPlaying == 1)
 468   4                      {
 469   5                          OLED_ShowString(3, 0, "game end", 16);
 470   5                          OLED_ShowString(3, 3, "your score", 16);
 471   5                          OLED_ShowValue(3, 6, track2_score, 16);
 472   5                          os_wait(K_IVL, 1000, 0); 
 473   5                          isPlaying = 0;
 474   5                      }
 475   4                  }
 476   3      
 477   3                  //此处添加玩家游戏后结算选择界面（回到主菜单或继续选歌）
 478   3      
 479   3                  //game_state == 0后 进入退出步骤
 480   3                  OLED_Clear();
 481   3                  os_wait(K_IVL, 100, 0);
 482   3                  game_state = 0;
 483   3      
 484   3                  os_create_task(2);  //激活菜单
 485   3                  os_delete_task(3);  //挂起游戏
 486   3              }
 487   2              else
 488   2              {
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 9   

 489   3                  os_wait(K_IVL, 100, 0);
 490   3              }
 491   2          }
 492   1      }
 493          
 494          // 积分任务
 495          void task_score(void) _task_ 4
 496          {
 497   1          while (game_state == 1)
 498   1          {
 499   2              if (isPlaying == 1)
 500   2              {
 501   3                  temp_score++;
 502   3                  os_wait(K_IVL, 100, 0);
 503   3              }
 504   2              else
 505   2              {
 506   3                  if (track_num == 1 && temp_score > track1_score)
 507   3                  {
 508   4                      track1_score = temp_score;
 509   4                      temp_score = 0;
 510   4                      os_delete_task(4);  //挂起积分
 511   4                  }
 512   3      
 513   3                  if (track_num == 2 && temp_score > track2_score)
 514   3                  {
 515   4                      track2_score = temp_score;
 516   4                      temp_score = 0;
 517   4                      os_delete_task(4);  //挂起积分
 518   4                  }
 519   3              }
 520   2          }
 521   1      }
 522          
 523          // 设置任务
 524          void task_setting(void) _task_ 5
 525          {
 526   1          while (1)
 527   1          {
 528   2              if (setting_state == 1)
 529   2              {
 530   3                  OLED_Init(); 
 531   3                  OLED_Clear();
 532   3                  os_wait(K_IVL, 10, 0);
 533   3                  P2 = 0x03;
 534   3                  x_position = 121 - speed * 2;
 535   3                  while(setting_state == 1)
 536   3                  {
 537   4                      os_wait(K_IVL, 1, 0);
 538   4                      OLED_ShowString(3, 3, "speed:", 16);
 539   4                      os_wait(K_IVL, 1, 0);
 540   4                      
 541   4                      // 传递字符串指针给 OLED_ShowString
 542   4                      OLED_ShowValue(60, 3, speed, 16); 
 543   4                      OLED_ShowString(16, 0, "$", 16);//判定点
 544   4                     
 545   4                      //移动Q（避免使用for而无法识别speed输入）
 546   4                      if (x_position > speed && x_position < 120 && KEY4_pressed == 0)
 547   4                      {
 548   5                          OLED_ShowString(x_position, 0, " ", 16);
 549   5                          x_position = x_position - speed;
 550   5                          OLED_ShowString(x_position, 0, "Q", 16);
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 16:10:03 PAGE 10  

 551   5                      }
 552   4                      else 
 553   4                      {
 554   5                          OLED_ShowString(x_position, 0, " ", 16);
 555   5                          OLED_ShowString(3, 6, "Miss   ", 8);
 556   5                          x_position = 121 - speed * 2;
 557   5                          KEY4_pressed = 0;
 558   5                      }
 559   4                      os_wait(K_IVL, 1, 0);
 560   4                  }
 561   3      
 562   3                  //setting_state == 0后 进入退出步骤
 563   3                  os_wait(K_IVL, 100, 0);
 564   3                  OLED_Clear();
 565   3                  os_create_task(2);  //激活菜单
 566   3                  os_delete_task(5);  //挂起设置
 567   3              }
 568   2              else
 569   2              {
 570   3                  os_wait(K_IVL, 100, 0);
 571   3              }
 572   2          }
 573   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2718    ----
   CONSTANT SIZE    =    277    ----
   XDATA SIZE       =     15    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
