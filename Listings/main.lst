C51 COMPILER V9.60.0.0   MAIN                                                              04/20/2025 17:37:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Headers;.\sources) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Headers/bmp.h"
   3          #include "Headers/oled.h"
   4          #include "Headers/oledfont.h"
   5          #include "Headers/RTX51TNY.H>
   6          
   7          sbit KEY1 = P3 ^ 1;
   8          sbit KEY2 = P3 ^ 0;
   9          sbit KEY3 = P3 ^ 2;
  10          sbit KEY4 = P3 ^ 3;
  11          
  12          // 游戏状态变量
  13          volatile unsigned char game_state = 0;          // 0: 主菜单，1: 游戏进行中
  14          volatile unsigned char setting_state = 0;       // 0: 主菜单，1: 设置界面
  15          volatile unsigned char score_state = 0;         // 0: 主菜单，1: 最高分界面
  16          volatile unsigned char board_num = 0;           // 0: start 1: setting 2: score
  17          
  18          // 初始化任务
  19          void task_init(void) _task_ 0
  20          {
  21   1          P2 = 0xFF;
  22   1          OLED_Init();
  23   1          OLED_DrawBMP(0, 0, 128, 8, BMP1);
  24   1          os_wait(K_IVL, 50, 0);
  25   1      
  26   1          os_create_task(1);  // 按键任务（优先级1）
  27   1          os_create_task(2);  // 菜单任务（优先级2）
  28   1          os_create_task(3);  // 游戏任务（优先级3）
  29   1          os_create_task(4);  // 积分任务（优先级4）
  30   1      
  31   1          os_delete_task(0);  // 删除自身
  32   1          while (1);  // 修复2：阻止任务重生
  33   1      }
  34          
  35          // 按键任务
  36          void task_key(void) _task_ 1
  37          {
  38   1          while(1)
  39   1          {
  40   2              /*主菜单中
  41   2              * key1 = up
  42   2              * key2 = down
  43   2              * key3 = comfirm
  44   2              */
  45   2              if (game_state == 0)
  46   2              {
  47   3                  if (KEY1 == 0)
  48   3                  {
  49   4                      os_wait(K_IVL, 3, 0); // 消抖
  50   4                      if (KEY1 == 0)         //等待按键释放
  51   4                      {
  52   5                          os_wait(K_IVL, 10, 0); // 消抖
  53   5                          board_num--;       //向上
  54   5                          if(board_num<0)
C51 COMPILER V9.60.0.0   MAIN                                                              04/20/2025 17:37:19 PAGE 2   

  55   5                              board_num = 2; //越界循环
  56   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
  57   5                      }
  58   4                      
  59   4                  }
  60   3                  
  61   3                  if (KEY2 == 0)
  62   3                  {
  63   4                      os_wait(K_IVL, 10, 0); // 消抖
  64   4                      while(KEY2 == 0);         //等待按键释放
  65   4                      os_wait(K_IVL, 10, 0); // 消抖
  66   4                      board_num++;        //向下
  67   4                      if(board_num>2)
  68   4                          board_num = 0;//越界循环
  69   4                      while (KEY2 == 0) os_wait(K_IVL, 1, 0);
  70   4                  }
  71   3                  
  72   3                  if (KEY3 == 0)
  73   3                  {
  74   4                      os_wait(K_IVL, 10, 0); // 消抖
  75   4                      while (KEY3 == 0);         //等待按键释放
  76   4                      os_wait(K_IVL, 10, 0); // 消抖
  77   4                          if (board_num == 0)//game选项下按下确认按键
  78   4                              game_state = 1;
  79   4                          if (board_num == 1)//setting选项下按下确认按键
  80   4                              setting_state = 1;
  81   4                          if (board_num == 2)//score选项下按下确认按钮
  82   4                              score_state = 1;
  83   4                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
  84   4                  }
  85   3                  os_wait(K_IVL, 20, 0);      //释放内存
  86   3                  
  87   3                  //主菜单下不需要按键4
  88   3              }
  89   2              /*游戏中
  90   2              * key1, key2 = sky
  91   2              * key3, key4 = ground
  92   2              */
  93   2              if (game_state == 1)
  94   2              {
  95   3          
  96   3              }
  97   2              /*设置中
  98   2              * key1 = plus
  99   2              * key2 = less
 100   2              * key3 = comfirm
 101   2              * key4 = back
 102   2              */
 103   2              if (setting_state == 1)
 104   2              {
 105   3      
 106   3              }
 107   2              /*计分板中
 108   2              * key4 = back
 109   2              */
 110   2              if (score_state == 1)
 111   2              {
 112   3      
 113   3              }
 114   2          }
 115   1      }
 116          
C51 COMPILER V9.60.0.0   MAIN                                                              04/20/2025 17:37:19 PAGE 3   

 117          // 菜单任务
 118          void task_board(void) _task_ 2
 119          {
 120   1          P2 = 0xAA;
 121   1          OLED_Clear();
 122   1          while (1)
 123   1          {
 124   2              while (game_state == 0 && score_state == 0 && setting_state == 0)
 125   2              { 
 126   3                  OLED_ShowString(25, 0, "Start", 16);
 127   3                  OLED_ShowString(25, 3, "Setting", 16);
 128   3                  OLED_ShowString(25, 6, "Score", 16);
 129   3                  switch (board_num)
 130   3                  {
 131   4                  case 0: 
 132   4                      OLED_ShowString(3, 0, ">>", 16);
 133   4                      OLED_ShowString(3, 3, "  ", 16);
 134   4                      OLED_ShowString(3, 6, "  ", 16);
 135   4                      break;
 136   4      
 137   4                  case 1: 
 138   4                      OLED_ShowString(3, 0, "  ", 16);
 139   4                      OLED_ShowString(3, 3, ">>", 16);
 140   4                      OLED_ShowString(3, 6, "  ", 16);
 141   4                      break;
 142   4      
 143   4                  case 2: 
 144   4                      OLED_ShowString(3, 0, "  ", 16);
 145   4                      OLED_ShowString(3, 3, "  ", 16);
 146   4                      OLED_ShowString(3, 6, ">>", 16);
 147   4                      break;
 148   4                  }
 149   3                  os_wait(K_IVL, 10, 0);  // 优化刷新率
 150   3              }
 151   2          }
 152   1      }
 153          
 154          // 游戏任务
 155          void task_game(void) _task_ 3
 156          {
 157   1          while (1)  // 修复5：使用永久循环
 158   1          {
 159   2              if (game_state == 1)
 160   2              {
 161   3                  OLED_Clear();
 162   3                  P2 = 0x01;
 163   3                  // 添加游戏逻辑
 164   3                  OLED_ShowString(3, 3, "gamestate now", 16); 
 165   3                  os_wait(K_TMO, 30, 0);
 166   3                  OLED_Clear();
 167   3                  game_state = 0;
 168   3              }
 169   2              else
 170   2              {
 171   3                  os_wait(K_IVL, 100, 0);
 172   3              }
 173   2          }
 174   1      }
 175          
 176          // 积分任务
 177          void task_score(void) _task_ 4
 178          {
C51 COMPILER V9.60.0.0   MAIN                                                              04/20/2025 17:37:19 PAGE 4   

 179   1          while (1)
 180   1          {
 181   2              if (score_state == 1)
 182   2              {
 183   3                  OLED_Clear();
 184   3                  P2 = 0x02;
 185   3                  // 添加积分显示逻辑
 186   3                  OLED_ShowString(3, 3, "scorestate now", 16); 
 187   3                  os_wait(K_TMO, 30, 0);
 188   3                  OLED_Clear();
 189   3                  score_state = 0;
 190   3              }
 191   2              else
 192   2              {
 193   3                  os_wait(K_IVL, 100, 0);
 194   3              }
 195   2          }
 196   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    597    ----
   CONSTANT SIZE    =   1079    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
