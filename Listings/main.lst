C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Headers;.\sources) DEBUG OB
                    -JECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Headers/bmp.h"
   3          #include "Headers/oled.h"
   4          #include "Headers/oledfont.h"
   5          #include "Headers/RTX51TNY.H"
   6          #include "Headers/music.h"
   7          
   8          sbit KEY1 = P3 ^ 1;
   9          sbit KEY2 = P3 ^ 0;
  10          sbit KEY3 = P3 ^ 2;
  11          sbit KEY4 = P3 ^ 3;
  12          
  13          
  14          
  15          // 游戏状态变量
  16          bit game_state = 0;          // 0: 主菜单，1: 游戏进行中
  17          bit setting_state = 0;       // 0: 主菜单，1: 设置界面
  18          bit score_state = 0;         // 0: 主菜单，1: 最高分界面
  19          volatile unsigned char board_num = 1;           // 1: start 2: setting 3: score
  20          volatile unsigned char x_position = 119;        //音符起始位置 119+8=127
  21          volatile unsigned char speed = 4;               //音符移动速度 1-8
  22          
  23          // 将 speed 转换为字符串
  24          char speed_str[2];  // 1位数字 + '\0'
  25          unsigned char temp ;
  26          bit KEY4_pressed = 0;        // 判定状态
  27          unsigned char hit_time = 0;
  28          
  29          unsigned char current_track = 1;//音符列位置 1-2
  30          
  31          // 初始化任务
  32          void task_init(void) _task_ 0
  33          {
  34   1          P2 = 0xFF;
  35   1          OLED_Init();
  36   1          OLED_DrawBMP(0, 0, 128, 8, BMP1);//logo
  37   1          os_wait(K_IVL, 50, 0);
  38   1      
  39   1          os_create_task(1);  // 按键任务（优先级1）
  40   1          os_create_task(2);  // 菜单任务（优先级2）
  41   1          //os_create_task(3);  // 游戏任务（优先级3）
  42   1          //os_create_task(4);  // 积分任务（优先级4）
  43   1          //os_create_task(5);  // 设置任务（优先级5）
  44   1      
  45   1          os_delete_task(0);  // 删除自身
  46   1      }
  47          
  48          // 按键任务
  49          void task_key(void) _task_ 1
  50          {
  51   1          while(1)
  52   1          {
  53   2              /*主菜单中
  54   2              * key1 = up
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 2   

  55   2              * key2 = down
  56   2              * key3 = comfirm
  57   2              */
  58   2              if (game_state == 0 && setting_state == 0 && score_state == 0)
  59   2              {
  60   3                  if (KEY1 == 0)
  61   3                  {
  62   4                      os_wait(K_IVL, 3, 0); // 消抖
  63   4                      if (KEY1 == 0)         //确认按钮按下
  64   4                      {
  65   5                          os_wait(K_IVL, 10, 0); // 消抖
  66   5                          board_num--;       //向上
  67   5                          if(board_num < 1)
  68   5                              board_num = 3; //越界循环
  69   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
  70   5                      }
  71   4                  }
  72   3                  
  73   3                  if (KEY2 == 0)
  74   3                  {
  75   4                      os_wait(K_IVL, 3, 0); // 消抖
  76   4                      if (KEY2 == 0)         //确认按钮按下
  77   4                      {
  78   5                          os_wait(K_IVL, 10, 0); // 消抖
  79   5                          board_num++;        //向下
  80   5                          if(board_num > 3)
  81   5                              board_num = 1;//越界循环
  82   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);// 等待释放
  83   5                      }
  84   4                     
  85   4                  }
  86   3                  
  87   3                  if (KEY3 == 0)
  88   3                  {
  89   4                      os_wait(K_IVL, 3, 0); // 消抖
  90   4                      if (KEY3 == 0)         //等待按键释放
  91   4                      {
  92   5                          os_wait(K_IVL, 10, 0); // 消抖  
  93   5                          switch (board_num)
  94   5                          {
  95   6                          //game选项下按下确认按键
  96   6                          case 1:
  97   6                              game_state = 1;
  98   6                              os_delete_task(2);  //挂起菜单
  99   6                              os_create_task(3);  //启动游戏任务（优先级3）
 100   6                              break;
 101   6                      
 102   6                          //setting选项下按下确认按键
 103   6                          case 2:
 104   6                              setting_state = 1;
 105   6                              os_delete_task(2);  //挂起菜单
 106   6                              os_create_task(5);  //启动设置任务（优先级5）
 107   6                              break;
 108   6      
 109   6                          //score选项下按下确认按钮
 110   6                          case 3:
 111   6                              score_state = 1;
 112   6                              os_delete_task(2);  //挂起菜单
 113   6                              os_create_task(4);  //启动积分任务（优先级4）
 114   6                              break;
 115   6                          }
 116   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 3   

 117   5                      }
 118   4                      
 119   4                  }
 120   3                  os_wait(K_IVL, 10, 0);      //释放内存
 121   3              }
 122   2      
 123   2              /*游戏中
 124   2              * key1 = sky
 125   2              * key2 = ground
 126   2              * key3 = quit
 127   2              * key4 = pause
 128   2              */
 129   2              if (game_state == 1)
 130   2              {
 131   3                  //退出游戏
 132   3                  if (KEY3 == 0)
 133   3                  {
 134   4                      os_wait(K_IVL, 3, 0); // 消抖
 135   4                      if (KEY3 == 0)
 136   4                      {
 137   5                          os_wait(K_IVL, 10, 0); // 消抖  
 138   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 139   5                      }
 140   4                      game_state = 0;
 141   4                      os_wait(K_IVL, 3, 0);
 142   4                  }
 143   3              }
 144   2      
 145   2              /*设置中
 146   2              * key1 = speed plus
 147   2              * key2 = speed less
 148   2              * key3 = comfirm & backward
 149   2              */
 150   2              if (setting_state == 1)
 151   2              {
 152   3                  //speed减少
 153   3                  if (KEY1 == 0)
 154   3                  {
 155   4                      os_wait(K_IVL, 3, 0); // 消抖
 156   4                      if (KEY1 == 0)
 157   4                      {
 158   5                          os_wait(K_IVL, 10, 0); // 消抖
 159   5                          speed--;       //speed减少
 160   5                          if (speed < 2)
 161   5                              speed = 1; //越界循环
 162   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
 163   5      
 164   5                      }
 165   4                      
 166   4                  }
 167   3      
 168   3                  //speed增加
 169   3                  if (KEY2 == 0)
 170   3                  {
 171   4                      os_wait(K_IVL, 3, 0); // 消抖
 172   4                      if (KEY2 == 0)         
 173   4                      {
 174   5                          os_wait(K_IVL, 10, 0); // 消抖
 175   5                          speed++;        //speed增加
 176   5                          if (speed > 7)
 177   5                              speed = 8;//越界循环
 178   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 4   

 179   5      
 180   5                      }
 181   4                  }
 182   3      
 183   3                  //退出设置
 184   3                  if (KEY3 == 0)
 185   3                  {
 186   4                      os_wait(K_IVL, 3, 0); // 消抖
 187   4                      if (KEY3 == 0)         
 188   4                      {
 189   5                          os_wait(K_IVL, 10, 0); // 消抖  
 190   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 191   5                      }
 192   4                      setting_state = 0;
 193   4                      os_wait(K_IVL, 3, 0);
 194   4                  }
 195   3      
 196   3                  //判定
 197   3                  if (KEY4 == 0)
 198   3                  {
 199   4                      os_wait(K_IVL, 3, 0); // 消抖
 200   4                      if (KEY4 == 0)
 201   4                      {
 202   5                          os_wait(K_IVL, 10, 0); // 消抖  
 203   5                          while (KEY4 == 0) os_wait(K_IVL, 1, 0);
 204   5                      }
 205   4                      KEY4_pressed = 1;
 206   4                      os_wait(K_IVL, 3, 0);
 207   4                  }
 208   3      
 209   3                  os_wait(K_IVL, 10, 0);      //释放内存
 210   3                  
 211   3              }
 212   2              /*计分板中
 213   2              * key3 = back
 214   2              */
 215   2              if (score_state == 1)
 216   2              {
 217   3                  //退出计分板
 218   3                  if (KEY3 == 0)
 219   3                  {
 220   4                      os_wait(K_IVL, 3, 0); // 消抖
 221   4                      if (KEY3 == 0);        
 222   4                      {
 223   5                          os_wait(K_IVL, 10, 0); // 消抖  
 224   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 225   5                      }
 226   4                      score_state = 0;
 227   4                      os_wait(K_IVL, 3, 0);
 228   4                  }
 229   3              }
 230   2          }
 231   1      }
 232          
 233          // 菜单任务
 234          void task_board(void) _task_ 2
 235          {
 236   1          OLED_Clear();
 237   1          while (1)
 238   1          {  
 239   2              os_wait(K_IVL, 10, 0);
 240   2              P2 = 0xAA;
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 5   

 241   2              while (game_state == 0 && score_state == 0 && setting_state == 0)
 242   2              {
 243   3                  OLED_ShowString(25, 0, "Start", 16);
 244   3                  OLED_ShowString(25, 3, "Setting", 16);
 245   3                  OLED_ShowString(25, 6, "Score", 16);
 246   3                  switch (board_num)
 247   3                  {
 248   4                  case 1: 
 249   4                      OLED_ShowString(3, 0, ">>", 16);
 250   4                      OLED_ShowString(3, 3, "  ", 16);
 251   4                      OLED_ShowString(3, 6, "  ", 16);
 252   4                      break;
 253   4      
 254   4                  case 2: 
 255   4                      OLED_ShowString(3, 0, "  ", 16);
 256   4                      OLED_ShowString(3, 3, ">>", 16);
 257   4                      OLED_ShowString(3, 6, "  ", 16);
 258   4                      break;
 259   4      
 260   4                  case 3: 
 261   4                      OLED_ShowString(3, 0, "  ", 16);
 262   4                      OLED_ShowString(3, 3, "  ", 16);
 263   4                      OLED_ShowString(3, 6, ">>", 16);
 264   4                      break;
 265   4                  }
 266   3                  os_wait(K_IVL, 10, 0);  
 267   3              }
 268   2          }
 269   1      }
 270          
 271          // 游戏任务
 272          void task_game(void) _task_ 3
 273          {
 274   1          while (1)  
 275   1          {
 276   2              if (game_state == 1)
 277   2              {
 278   3                  OLED_Clear();
 279   3                  P2 = 0x01;
 280   3                  Music_Init(Track1); 
 281   3                  //暂未添加游戏逻辑
 282   3                  while (game_state == 1)
 283   3                  {   
 284   4                      Music_play();
 285   4                      OLED_ShowString(3, 3, "gamestate now", 16);
 286   4                  }
 287   3                  //game_state == 0后 进入退出步骤
 288   3                  OLED_Clear();
 289   3                  os_wait(K_IVL, 100, 0);
 290   3                  game_state = 0;
 291   3                  os_create_task(2);  //激活菜单
 292   3                  os_delete_task(3);  //挂起游戏
 293   3              }
 294   2              else
 295   2              {
 296   3                  os_wait(K_IVL, 100, 0);
 297   3              }
 298   2          }
 299   1      }
 300          
 301          // 积分任务
 302          void task_score(void) _task_ 4
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 6   

 303          {
 304   1          
 305   1          while (1)
 306   1          {
 307   2              if (score_state == 1)
 308   2              {
 309   3                  OLED_Init(); 
 310   3                  OLED_Clear();
 311   3                  P2 = 0x02;
 312   3                  // 添加积分显示逻辑
 313   3                  while (score_state == 1)
 314   3                  {
 315   4                      OLED_ShowString(3, 3, "track1 = 100000", 16); 
 316   4                      OLED_ShowString(3, 6, "track2 = 100000", 16);
 317   4                      
 318   4                      os_wait(K_IVL, 20, 0);
 319   4                  }
 320   3                  //score_state == 0后 进入退出步骤
 321   3                  os_wait(K_IVL, 100, 0);
 322   3                  OLED_Clear();
 323   3                  os_create_task(2);  //激活菜单
 324   3                  os_delete_task(4);  //挂起积分
 325   3              }
 326   2              else
 327   2              {
 328   3                  os_wait(K_IVL, 100, 0);
 329   3              }
 330   2          }
 331   1      }
 332          
 333          // 设置任务
 334          void task_setting(void) _task_ 5
 335          {
 336   1          while (1)
 337   1          {
 338   2              if (setting_state == 1)
 339   2              {
 340   3                  OLED_Init(); 
 341   3                  OLED_Clear();
 342   3                  os_wait(K_IVL, 10, 0);
 343   3                  P2 = 0x03;
 344   3                  x_position = 121 - speed * 2;
 345   3                  while(setting_state == 1)
 346   3                  {
 347   4                      temp = speed;
 348   4                      os_wait(K_IVL, 1, 0);
 349   4      
 350   4                      //showstring需要一个U8参数 而speed无法直接输出
 351   4                      speed_str[0] = temp % 10 + '0';          // 得到speed的值
 352   4                      speed_str[1] = '\0';                     // 字符串结束符
 353   4      
 354   4                      os_wait(K_IVL, 1, 0);
 355   4                      OLED_ShowString(3, 3, "speed:", 16);
 356   4                      os_wait(K_IVL, 1, 0);
 357   4                      
 358   4                      // 传递字符串指针给 OLED_ShowString
 359   4                      OLED_ShowString(60, 3, speed_str, 16);  // 强制转换类型 输出当前speed值
 360   4                      OLED_ShowString(16, 0, "$", 16);//判定点
 361   4                      hit_time = (x_position - 16) / speed;
 362   4                      if (x_position < 31 && KEY4_pressed == 1)
 363   4                      {
 364   5                          if (hit_time < 1) 
C51 COMPILER V9.60.0.0   MAIN                                                              04/25/2025 09:39:06 PAGE 7   

 365   5                          {
 366   6                              OLED_ShowString(3, 6, "Perfect", 16);
 367   6                          }
 368   5                          else if (hit_time < 2)
 369   5                          {
 370   6                              OLED_ShowString(3, 6, "Good   ", 16);
 371   6                          }
 372   5                          else if(hit_time < 3)
 373   5                          {
 374   6                              OLED_ShowString(3, 6, "Bad    ", 16);
 375   6                          }
 376   5                          OLED_ShowString(x_position, 0, " ", 16);
 377   5                          x_position = 121 - speed * 2;
 378   5                          KEY4_pressed = 0;
 379   5                          continue;
 380   5                      }
 381   4                      //移动Q（避免使用for而无法识别speed输入）
 382   4                      if (x_position > speed && x_position < 120 && KEY4_pressed == 0)
 383   4                      {
 384   5                          OLED_ShowString(x_position, 0, " ", 16);
 385   5                          x_position = x_position - speed;
 386   5                          OLED_ShowString(x_position, 0, "Q", 16);
 387   5                      }
 388   4                      else 
 389   4                      {
 390   5                          OLED_ShowString(x_position, 0, " ", 16);
 391   5                          if(x_position < speed)
 392   5                              OLED_ShowString(3, 6, "Miss   ", 16);
 393   5                          x_position = 121 - speed * 2;
 394   5                          KEY4_pressed = 0;
 395   5                      }
 396   4                      os_wait(K_IVL, 1, 0);
 397   4                  }
 398   3      
 399   3                  //setting_state == 0后 进入退出步骤
 400   3                  os_wait(K_IVL, 100, 0);
 401   3                  OLED_Clear();
 402   3                  os_create_task(2);  //激活菜单
 403   3                  os_delete_task(5);  //挂起设置
 404   3              }
 405   2              else
 406   2              {
 407   3                  os_wait(K_IVL, 100, 0);
 408   3              }
 409   2          }
 410   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1590    ----
   CONSTANT SIZE    =   1141    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
