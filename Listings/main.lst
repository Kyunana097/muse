C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Headers;.\sources) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Headers/bmp.h"
   3          #include "Headers/oled.h"
   4          #include "Headers/oledfont.h"
   5          #include "Headers/RTX51TNY.H"
   6          
   7          sbit KEY1 = P3 ^ 1;
   8          sbit KEY2 = P3 ^ 0;
   9          sbit KEY3 = P3 ^ 2;
  10          sbit KEY4 = P3 ^ 3;
  11          
  12          // 游戏状态变量
  13          bit game_state = 0;          // 0: 主菜单，1: 游戏进行中
  14          bit setting_state = 0;       // 0: 主菜单，1: 设置界面
  15          bit score_state = 0;         // 0: 主菜单，1: 最高分界面
  16          volatile unsigned char board_num = 1;           // 1: start 2: setting 3: score
  17          volatile unsigned char x_position = 119;        //音符起始位置 119+8=127
  18          volatile unsigned char speed = 4;               //音符移动速度 1-8
  19          
  20          // 将 speed 转换为字符串
  21          char speed_str[2];  // 1位数字 + '\0'
  22          unsigned char temp ;
  23          bit KEY4_pressed = 0;        // 判定状态
  24          unsigned char hit_time = 0;
  25          
  26          unsigned char current_track = 1;//音符列位置 1-2
  27          
  28          // 初始化任务
  29          void task_init(void) _task_ 0
  30          {
  31   1          P2 = 0xFF;
  32   1          OLED_Init();
  33   1          OLED_DrawBMP(0, 0, 128, 8, BMP1);//logo
  34   1          os_wait(K_IVL, 50, 0);
  35   1      
  36   1          os_create_task(1);  // 按键任务（优先级1）
  37   1          os_create_task(2);  // 菜单任务（优先级2）
  38   1          //os_create_task(3);  // 游戏任务（优先级3）
  39   1          //os_create_task(4);  // 积分任务（优先级4）
  40   1          //os_create_task(5);  // 设置任务（优先级5）
  41   1          os_create_task(6);  // 音乐任务（优先级6）
  42   1      
  43   1          os_delete_task(0);  // 删除自身
  44   1      }
  45          
  46          // 按键任务
  47          void task_key(void) _task_ 1
  48          {
  49   1          while(1)
  50   1          {
  51   2              /*主菜单中
  52   2              * key1 = up
  53   2              * key2 = down
  54   2              * key3 = comfirm
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 2   

  55   2              */
  56   2              if (game_state == 0 && setting_state == 0 && score_state == 0)
  57   2              {
  58   3                  if (KEY1 == 0)
  59   3                  {
  60   4                      os_wait(K_IVL, 3, 0); // 消抖
  61   4                      if (KEY1 == 0)         //确认按钮按下
  62   4                      {
  63   5                          os_wait(K_IVL, 10, 0); // 消抖
  64   5                          board_num--;       //向上
  65   5                          if(board_num < 1)
  66   5                              board_num = 3; //越界循环
  67   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
  68   5                      }
  69   4                  }
  70   3                  
  71   3                  if (KEY2 == 0)
  72   3                  {
  73   4                      os_wait(K_IVL, 3, 0); // 消抖
  74   4                      if (KEY2 == 0)         //确认按钮按下
  75   4                      {
  76   5                          os_wait(K_IVL, 10, 0); // 消抖
  77   5                          board_num++;        //向下
  78   5                          if(board_num > 3)
  79   5                              board_num = 1;//越界循环
  80   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);// 等待释放
  81   5                      }
  82   4                     
  83   4                  }
  84   3                  
  85   3                  if (KEY3 == 0)
  86   3                  {
  87   4                      os_wait(K_IVL, 3, 0); // 消抖
  88   4                      if (KEY3 == 0)         //等待按键释放
  89   4                      {
  90   5                          os_wait(K_IVL, 10, 0); // 消抖  
  91   5                          switch (board_num)
  92   5                          {
  93   6                          //game选项下按下确认按键
  94   6                          case 1:
  95   6                              game_state = 1;
  96   6                              os_delete_task(2);  //挂起菜单
  97   6                              os_create_task(3);  //启动游戏任务（优先级3）
  98   6                              break;
  99   6                      
 100   6                          //setting选项下按下确认按键
 101   6                          case 2:
 102   6                              setting_state = 1;
 103   6                              os_delete_task(2);  //挂起菜单
 104   6                              os_create_task(5);  //启动设置任务（优先级5）
 105   6                              break;
 106   6      
 107   6                          //score选项下按下确认按钮
 108   6                          case 3:
 109   6                              score_state = 1;
 110   6                              os_delete_task(2);  //挂起菜单
 111   6                              os_create_task(4);  //启动积分任务（优先级4）
 112   6                              break;
 113   6                          }
 114   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 115   5                      }
 116   4                      
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 3   

 117   4                  }
 118   3                  os_wait(K_IVL, 10, 0);      //释放内存
 119   3              }
 120   2      
 121   2              /*游戏中
 122   2              * key1 = sky
 123   2              * key2 = ground
 124   2              * key3 = quit
 125   2              * key4 = pause
 126   2              */
 127   2              if (game_state == 1)
 128   2              {
 129   3                  //退出游戏
 130   3                  if (KEY3 == 0)
 131   3                  {
 132   4                      os_wait(K_IVL, 3, 0); // 消抖
 133   4                      if (KEY3 == 0)
 134   4                      {
 135   5                          os_wait(K_IVL, 10, 0); // 消抖  
 136   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 137   5                      }
 138   4                      game_state = 0;
 139   4                      os_wait(K_IVL, 3, 0);
 140   4                  }
 141   3              }
 142   2      
 143   2              /*设置中
 144   2              * key1 = speed plus
 145   2              * key2 = speed less
 146   2              * key3 = comfirm & backward
 147   2              */
 148   2              if (setting_state == 1)
 149   2              {
 150   3                  //speed减少
 151   3                  if (KEY1 == 0)
 152   3                  {
 153   4                      os_wait(K_IVL, 3, 0); // 消抖
 154   4                      if (KEY1 == 0)
 155   4                      {
 156   5                          os_wait(K_IVL, 10, 0); // 消抖
 157   5                          speed--;       //speed减少
 158   5                          if (speed < 2)
 159   5                              speed = 1; //越界循环
 160   5                          while (KEY1 == 0) os_wait(K_IVL, 1, 0); // 等待释放
 161   5      
 162   5                      }
 163   4                      
 164   4                  }
 165   3      
 166   3                  //speed增加
 167   3                  if (KEY2 == 0)
 168   3                  {
 169   4                      os_wait(K_IVL, 3, 0); // 消抖
 170   4                      if (KEY2 == 0)         
 171   4                      {
 172   5                          os_wait(K_IVL, 10, 0); // 消抖
 173   5                          speed++;        //speed增加
 174   5                          if (speed > 7)
 175   5                              speed = 8;//越界循环
 176   5                          while (KEY2 == 0) os_wait(K_IVL, 1, 0);
 177   5      
 178   5                      }
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 4   

 179   4                  }
 180   3      
 181   3                  //退出设置
 182   3                  if (KEY3 == 0)
 183   3                  {
 184   4                      os_wait(K_IVL, 3, 0); // 消抖
 185   4                      if (KEY3 == 0)         
 186   4                      {
 187   5                          os_wait(K_IVL, 10, 0); // 消抖  
 188   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 189   5                      }
 190   4                      setting_state = 0;
 191   4                      os_wait(K_IVL, 3, 0);
 192   4                  }
 193   3      
 194   3                  //判定
 195   3                  if (KEY4 == 0)
 196   3                  {
 197   4                      os_wait(K_IVL, 3, 0); // 消抖
 198   4                      if (KEY4 == 0)
 199   4                      {
 200   5                          os_wait(K_IVL, 10, 0); // 消抖  
 201   5                          while (KEY4 == 0) os_wait(K_IVL, 1, 0);
 202   5                      }
 203   4                      KEY4_pressed = 1;
 204   4                      os_wait(K_IVL, 3, 0);
 205   4                  }
 206   3      
 207   3                  os_wait(K_IVL, 10, 0);      //释放内存
 208   3                  
 209   3              }
 210   2              /*计分板中
 211   2              * key3 = back
 212   2              */
 213   2              if (score_state == 1)
 214   2              {
 215   3                  //退出计分板
 216   3                  if (KEY3 == 0)
 217   3                  {
 218   4                      os_wait(K_IVL, 3, 0); // 消抖
 219   4                      if (KEY3 == 0);        
 220   4                      {
 221   5                          os_wait(K_IVL, 10, 0); // 消抖  
 222   5                          while (KEY3 == 0) os_wait(K_IVL, 1, 0);
 223   5                      }
 224   4                      score_state = 0;
 225   4                      os_wait(K_IVL, 3, 0);
 226   4                  }
 227   3              }
 228   2          }
 229   1      }
 230          
 231          // 菜单任务
 232          void task_board(void) _task_ 2
 233          {
 234   1          OLED_Clear();
 235   1          while (1)
 236   1          {  
 237   2              os_wait(K_IVL, 10, 0);
 238   2              P2 = 0xAA;
 239   2              while (game_state == 0 && score_state == 0 && setting_state == 0)
 240   2              {
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 5   

 241   3                  OLED_ShowString(25, 0, "Start", 16);
 242   3                  OLED_ShowString(25, 3, "Setting", 16);
 243   3                  OLED_ShowString(25, 6, "Score", 16);
 244   3                  switch (board_num)
 245   3                  {
 246   4                  case 1: 
 247   4                      OLED_ShowString(3, 0, ">>", 16);
 248   4                      OLED_ShowString(3, 3, "  ", 16);
 249   4                      OLED_ShowString(3, 6, "  ", 16);
 250   4                      break;
 251   4      
 252   4                  case 2: 
 253   4                      OLED_ShowString(3, 0, "  ", 16);
 254   4                      OLED_ShowString(3, 3, ">>", 16);
 255   4                      OLED_ShowString(3, 6, "  ", 16);
 256   4                      break;
 257   4      
 258   4                  case 3: 
 259   4                      OLED_ShowString(3, 0, "  ", 16);
 260   4                      OLED_ShowString(3, 3, "  ", 16);
 261   4                      OLED_ShowString(3, 6, ">>", 16);
 262   4                      break;
 263   4                  }
 264   3                  os_wait(K_IVL, 10, 0);  
 265   3              }
 266   2          }
 267   1      }
 268          
 269          // 游戏任务
 270          void task_game(void) _task_ 3
 271          {
 272   1          while (1)  
 273   1          {
 274   2              if (game_state == 1)
 275   2              {
 276   3                  OLED_Clear();
 277   3      
 278   3                  P2 = 0x01;
 279   3                  //暂未添加游戏逻辑
 280   3                  while (game_state == 1)
 281   3                  {
 282   4                      OLED_ShowString(3, 3, "gamestate now", 16); 
 283   4                  }
 284   3                  //game_state == 0后 进入退出步骤
 285   3                  OLED_Clear();
 286   3                  os_wait(K_IVL, 100, 0);
 287   3                  game_state = 0;
 288   3                  os_create_task(2);  //激活菜单
 289   3                  os_delete_task(3);  //挂起游戏
 290   3              }
 291   2              else
 292   2              {
 293   3                  os_wait(K_IVL, 100, 0);
 294   3              }
 295   2          }
 296   1      }
 297          
 298          // 积分任务
 299          void task_score(void) _task_ 4
 300          {
 301   1          
 302   1          while (1)
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 6   

 303   1          {
 304   2              if (score_state == 1)
 305   2              {
 306   3                  OLED_Init(); 
 307   3                  OLED_Clear();
 308   3                  P2 = 0x02;
 309   3                  // 添加积分显示逻辑
 310   3                  while (score_state == 1)
 311   3                  {
 312   4                      OLED_ShowString(3, 3, "track1 = 100000", 16); 
 313   4                      OLED_ShowString(3, 6, "track2 = 100000", 16);
 314   4                      
 315   4                      os_wait(K_IVL, 20, 0);
 316   4                  }
 317   3                  //score_state == 0后 进入退出步骤
 318   3                  os_wait(K_IVL, 100, 0);
 319   3                  OLED_Clear();
 320   3                  os_create_task(2);  //激活菜单
 321   3                  os_delete_task(4);  //挂起积分
 322   3              }
 323   2              else
 324   2              {
 325   3                  os_wait(K_IVL, 100, 0);
 326   3              }
 327   2          }
 328   1      }
 329          
 330          // 设置任务
 331          void task_setting(void) _task_ 5
 332          {
 333   1          while (1)
 334   1          {
 335   2              if (setting_state == 1)
 336   2              {
 337   3                  OLED_Init(); 
 338   3                  OLED_Clear();
 339   3                  os_wait(K_IVL, 10, 0);
 340   3                  P2 = 0x03;
 341   3                  x_position = 121 - speed * 2;
 342   3                  while(setting_state == 1)
 343   3                  {
 344   4                      temp = speed;
 345   4                      os_wait(K_IVL, 1, 0);
 346   4      
 347   4                      //showstring需要一个U8参数 而speed无法直接输出
 348   4                      speed_str[0] = temp % 10 + '0';          // 得到speed的值
 349   4                      speed_str[1] = '\0';                     // 字符串结束符
 350   4      
 351   4                      os_wait(K_IVL, 1, 0);
 352   4                      OLED_ShowString(3, 3, "speed:", 16);
 353   4                      os_wait(K_IVL, 1, 0);
 354   4                      
 355   4                      // 传递字符串指针给 OLED_ShowString
 356   4                      OLED_ShowString(60, 3, speed_str, 16);  // 强制转换类型 输出当前speed值
 357   4                      OLED_ShowString(16, 0, "$", 16);//判定点
 358   4                      hit_time = (x_position - 16) / speed;
 359   4                      if (x_position < 31 && KEY4_pressed == 1)
 360   4                      {
 361   5                          if (hit_time < 1) 
 362   5                          {
 363   6                              OLED_ShowString(3, 6, "Perfect", 16);
 364   6                          }
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 7   

 365   5                          else if (hit_time < 2)
 366   5                          {
 367   6                              OLED_ShowString(3, 6, "Good   ", 16);
 368   6                          }
 369   5                          else
 370   5                          {
 371   6                              OLED_ShowString(3, 6, "Bad    ", 16);
 372   6                          }
 373   5                      }
 374   4                      //移动Q（避免使用for而无法识别speed输入）
 375   4                      if (x_position > speed && x_position < 120 && KEY4_pressed == 0)
 376   4                      {
 377   5                          OLED_ShowString(x_position, 0, " ", 16);
 378   5                          x_position = x_position - speed;
 379   5                          OLED_ShowString(x_position, 0, "Q", 16);
 380   5                      }
 381   4                      else 
 382   4                      {
 383   5                          OLED_ShowString(x_position, 0, " ", 16);
 384   5                          x_position = 121 - speed * 2;
 385   5                          KEY4_pressed = 0;
 386   5                      }
 387   4                      os_wait(K_IVL, 1, 0);
 388   4                  }
 389   3      
 390   3                  //setting_state == 0后 进入退出步骤
 391   3                  os_wait(K_IVL, 100, 0);
 392   3                  OLED_Clear();
 393   3                  os_create_task(2);  //激活菜单
 394   3                  os_delete_task(5);  //挂起设置
 395   3              }
 396   2              else
 397   2              {
 398   3                  os_wait(K_IVL, 100, 0);
 399   3              }
 400   2          }
 401   1      }
 402          
 403          //蜂鸣器任务（未启用 需使用定时器1）
 404          void task_beep(void) _task_ 6
 405          {
 406   1          while (1)
 407   1          {
 408   2              if (game_state == 1)
 409   2              {
 410   3                  os_wait(K_IVL, 100, 0);
 411   3              }
 412   2              else
 413   2              {
 414   3                  os_wait(K_IVL, 100, 0);
 415   3              }
 416   2          }
 417   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1401    ----
   CONSTANT SIZE    =   1133    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   MAIN                                                              04/24/2025 09:40:13 PAGE 8   

   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
